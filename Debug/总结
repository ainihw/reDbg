win32Sdk开发小型调试器（开发文档）


1.总体思路

一个调试线程，一个UI线程。
调试线程用来接收调试事件，UI线程用来接收用户的操作。
通过挂起调试线程接收用户操作后，继续执行程序
调试进程与线程之间通过全局变量进行交互。

2.主要功能
断点：
硬件断点（硬件写，硬件读，硬件执行）
软件断点（int3）
内存断点（内存写，内存读）
其他功能：
打开，附加进程
单步步过，单步步入，入口断点

3.主要功能及其实现
	3.1硬件断点（执行断点）
	通过设置调试寄存器，产生硬件调试异常后在调试线程中捕捉。然后先将调试寄存器激活条件冻结，在设置单步标志（为的是在恢复硬件断点）
	为什么要这么做呢，因为硬件执行断点是错误类异常，当执行完指令后eip又会指向引发异常的指令处。如果你不先冻结激活条件，那么会一直引发硬件执行异常，程序无法继续执行。
	
	3.2硬件断点（写断点，读断点）
	也是在调试线程中捕捉异常后，不需要设置单步标志，直接等待用户操作后继续运行。
	因为硬件写和硬件读都是陷阱类异常。执行完指令引发异常的时候，eip已经指向引发异常的下一条指令了。
	
	3.3软件断点
	通过将指令的第一个字节修改为0xCC，并在断点链表中增减结点来设置int3断点。
	在调试线程中捕捉断点异常后先把原字节修改回来后，设置单步标志（为了恢复恢复int3断点）。等待用户操作后继续执行程序。
	
	3.4内存断点
	通过修改内存处的属性，在调试线程中捕捉访问异常，然后将内存原来的属性还原，在设置单步标志（为了恢复内存断点）
	内存断点也是错误类断点，所以需要这样做。
	
	3.5入口断点
	在程序入口点处设置int3断点
	
	3.6单步步过
	通过在下一条指令处设置0xCC，然后运行程序达到单步的目的。如果待执行的指令不是call则让单步步过变单步步入
	
	3.7单步步入
	通过设置单步标志，在调试线程中捕捉单步异常，等待用户操作后继续执行程序。
	
4.遇到的问题及其解决方法
	4.1模态对话框不能作为子窗口（child）。子窗口只能在父窗口的客户区显示，所以模态对话框如果作为子窗口，当你点击模态对话框的时候是父窗口的客户区先收到消息。
	又因为模态对话框的机制是如果你不关闭它就不能点击其他窗口。所以整个窗口就无法相应消息，一直发出”噔噔蹬“的声音（我自己的理解）
	父窗口（parent）和拥有者窗口（occupant）不一样，（其联系与区别）
	
	
	
	
	4.2 CreateDialogParam()创建非模态对话框的时候，虽然其消息循环在外部，但并不是调用完就立刻返回到消息循环，
	其需要根据对话框资源在内部在默认窗口类“#32720”基础上调用CreateWindowEx创建窗口，发送消息WM_CREATE,WM_INITDIALOG消息到对话框管理器中，然后消息在传到消息回调函数中，
	当对话框回调函数（或对话框管理器）处理完这些消息后CreateWindowEx才会返回
	DialogParam()创建模态对话框的时候，因为其是内建消息循环，当调用完DialogParam后如果内部消息循环不退出，则DialogParam不返回。这也是模态对话框没关闭时不能点击其他窗口的原因。
	
	4.3 进程快照只能得到进程的可执行文件名称，无法得到进程的完整路径。需要先根据PID调用OpenProcess获得进程句柄后，在由进程句柄调用GetProcessImageFileName得到进程的DOS路径，然后再把dos路径传化为NT路径
	
	
	
	
	4.4 获得一个指定进程的线程句柄，如果没有线程PID，可以通过创建线程快照然后根据判断线程句柄的进程的PID是否等于我们所要获得进程的PID，来获得指定进程的线程PID.
	
	4.5 怎么获得一个已运行进程的基地址。可以先创建进程快照得到进程PID，然后在创建此进程的模块快照得到第一个模块的基地址，极为此进程的基地址
	
	4.6 附件进程的时候如果DebugActiveProcess（）和调试事件循环不在一个线程中就会调试循环就会接收不到调试事件


	4.7 利用EnumChildWindows和其回调函数EnumChildProc获得指定窗口子窗口的句柄
	
	4.8 VirtualProtectEx()改变指定内存属性时，最后一个参数用来接收内存原属性，其必须指定不能传NULL
	
	4.9 strtol()将指定数字字符串按指定进程传化为数值
	
	4.10 调试线程在接收到进程退出事件时EXIT_PROCESS_DEBUG_EVENT，需要在自己处理完相应操作后在交给ContinueDebugEvent处理，如果没让ContinueDebugEvent处理进程就无法真正退出调试并结束进程
	
	4.11 如何获得被调试线程的基地址，存在随机基址（在创建调试线程后获得线程的eax即为其基地址）
	
	